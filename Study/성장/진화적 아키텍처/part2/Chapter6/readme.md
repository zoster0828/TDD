# 진화적 데이터
## 6.1 진화적 데이터베이스 설계
* 진화적 데이터베이스 설계란 요구 사항의 변화에 따라 발전하는 구축하는 것
* 개발자와 데이터팀은 데이터베이스 설계를 통해 실제 세계를 추상화한다
* 따라서 실제 세계의 변화는 반드시 이 추상화에 반영되어야 한다

### 6.1.1 진화적 스키마
* 진화적 데이터베이스 설계의 핵심은 진화하는 스키마이다
* 개발자는 데이터베이스 변경사항을 소스코드처럼 테스트하고 버저닝하고 증분 형태로 관리해야 한다

**테스트**
* 데이터베이스 스키마의 변경사항을 엄격하게 테스트해야 한다
* ORM을 사용한다면 매핑 코드와 스키마를 항상 동기화 시켜야 한다

**버전 관리**
* 개발자와 데이터팀은 데이터베이스 스키마와 관련 코드에 버전을 지정해야 한다

**증분 변경**
* 소스의 변경이 기록으로 쌓이듯 데이터베이스 스키마의 변경 사항도 증분 방식으로 기록해야 한다

### 6.1.2 공유 데이터베이스 통합
* 일반적으로 사용되는 공유 데이터베이스 통합 패턴은 데이터베이스를 공유 메커니즘으로 사용하는 통합 패턴이다
* 그러나 데이터베이스를 통합 지점으로 활용하면 이를 공유하는 모든 프로젝트에서 스키마가 고착화될 우려가 있다
* A가 스키마를 변경하면 다른 두 어플리케이션에서도 잠재적인 장애의 위험에 처한다

**how to solve this problem?**
* 확장/수축 패턴
> 우리는 흔히 2 step 배포라고 부름

* 이전 상태와 변경 상태를 동시에 유지한다
```JAVA
class A{
    String name; // legacy
    String firstName; // new
    String lastName; // new
  
    public A(String name) { // legacy
        firstName = extractFirst(name);
        lastName = extractLast(name);
        name = name;
    }
    
    public A(String firstName, String lastName) { // new
        firstName = firstName;
        lastName = lastName;
        name = firstName + " " + lastName;
    }
}
```
* 전환 기간 동안 이전 버전과의 호환성을 보장하고 다른 부분들이 변경할 수 있는 여유가 생긴다
> 통합 기간이 무한히 길어질 수 있지 않을까?

## 6.2 부적절한 데이터 얽힘
### 6.2.1 2단계 커밋 트랜잭션
* 스키마의 커플링이 진화를 방해하듯, 트랜잭션 커플링은 컴포넌트를 구체적인 방식으로 결합시키고 진화를 방해한다
* 트랜잭션은
  * 복잡한 시스템을 전역적으로 제어하기 어렵기 때문
  * 경계를 조사하면 비즈니스적 개념과 실제 구현의 결합을 확인할 수 있다
  * 트랜잭션 컨텍스트를 데이터팀이 관할한다면 아키텍처의 기술적 커플링처럼 분리하기 쉽지 않다(?)
* 아키텍트는 애플리케이션의 모든 특성을 고려해야 한다
  * 트랜잭션 컨텍스트는 시스템에서 불가피한 경우가 많지만 가급적 제한해야 한다
  * 견고한 커플링을 형성하고 일부 컴포넌트나 서비스의 변경에서 다른 요소에 파급효과를 낳기 때문
* 마이크로 서비스를 위해서 크기를 줄이는것 보다는 경계 컨텍스트를 포착하는 것이 더 중요하다

### 6.2.2 데이터의 연식과 품질
* 데이터와 데이터베이스에 대한 맹목적 숭배는 대기업에서 흔히 드러나는 역기능 중 하나다
  * "애플리케이션은 수명이 짧다. 데이터는 영원하다."
  * 스키마가 코드보다 드물게 변경되는 것은 사실이다
  * 스키마가 실제 세계를 추상화한것도 사실이기 때문에 변하는 세계에서 스키마가 불변이라 믿는 것은 현실을 부정하는 것이다
* 변화하는 세계의 새로운 추상화 요건을 스키마에 반영하려면 어떻게 할 수 있을까?
  * 일반적으로 조인 테이블을 추가하는 경우가 많음, 기존 시스템을 변경하기보다는 새로운 테이블을 추가하고 조인을 활용한다
  * 결과적으로는 본래의 추상화 구조를 난독화 시키는 결과를 초래한다
  * 추상화는 본래 하하나의 엔티티로 여러 사물을 표현하는 것인데, 오랜기간 스키마를 재구성하지 않은 경우 점차 화석화된 세계가 구축된다

> Status에 index를 추가하기 싫었던 어떤 서비스에서는 특정 status를 위한 table을 추가하고 조인해서 처리했다.
> 
> 시간이 지나 테이블의 consistency 관리에 실패하며 존재하지만 의미 없는 테이블로 처리할 수 밖에 없었고(너무 많이 깨지기 시작해서) 제거하는 결정에 이른다 
> 
> 그 외에도 여러 문제가 있었는데 특정 status만 볼 수 있는 api만 존재하고 있어서 다른 status를 위해
> 
> api를 추가하려는 결정을 하고자 했을때 분석결과 새 table을 추가해야만 한다는 것을 알게된다
> 
> 이처럼 외부에서 시스템을 관측했을때 시스템을 예측하기 어렵게 된다

* 진정한 가치를 지닌 데이터는 살피고 보존하는 한편 낡고 쓸모없는 데이터는 진화의 본류에서 배제하자

### 6.2.3 PenultimateWidgest의 라우팅 진화
* 확장 / 수축 패턴을 이용한 라우팅 테이블 진화
* 지속적 통합, 소스 관리 등의 우수한 엔지니어링 관행을 개발자들이 적용하면 데이터베이스도 아키텍처와 나란히 올바르게 진화할 수 있다
* 데이터베이스의 구조는 실제 세계를 바탕으로 추상화된다, 이러한 데이터는 변화에 대응보다는 저항하려는 성향이 강하지만 
아키텍트는 데이터를 진화적 아키텍처의 주요 관심사로 취급해야 한다

## 6.3 네이티브에서 피트니스 함수로
* 아키텍트가 마이크로서비스 아키텍처를 채택하고 경계 컨텍스트당 하나의 데이터베이스를 배정하면, 데이터팀의 관점에 변화가 생긴다
* 데이터가 구조적으로 연결되는 지점의 정확성을 유지하기 위해 참조 무결성에 세심한 주의를 기울인다
* 마이크로서비스의 장점을 위해 데이터팀의 메커니즘을 일부 포기하게 하고 긍정적으로 전환하려면 어떻게 해야 할까
  * 또트니스 함수다!

### 6.3.1 참조 무결성
* 아키텍처 커플링이 아닌 데이터 스키마 수준에서 형성되는 거버넌스의 일종이다
* 아키텍트는 정보 소유자가 특정 항목을 삭제했을 경우 이를 참조하는 다른 서비스에 삭제 사실을 알리는 피트니스 함수를 작성해야 한다

### 6.3.2 데이터 중복
* 하나의 관계형 데이터베이스만 다루다 보면 읽기와 쓰기라는 두 작업이 별개라는 사실을 잊게 되는 경우가 많다

* 공유 테이블 스키마의 변경 사항은 결합된 서비스에 영향을 미치며 결과적으로 각 서비스를 변경하도록 강요한다
  * 해결하기 위해 각 공유 정보 비트를 별도 서비스로 모델링하면 통신이 폭증했을때 성능에 영향을 준다
  * 데이터를 소유할 사용자와 데이터 일부를 조회할 사용자를 세밀하게 구별하는 방식으로 해소할 수 있다

### 6.3.3 트리거 및 저장 프로시저 대체
* 저장 프로시저는 데이터팀이 자주 애용하는 기술 중 하나다
* 프로시저는 단위 테스트로 검증하기 어렵고 리팩토링 난도가 높고 코드의 동작과 분리된 별도의 동작을 수행한다는 문제가 있다
* 확장 수축을 통해 저장 프로시저의 동작을 애플리케이션 코드로 추출해보자
  * 확장 단계에서 개발자는 위젯 관리 서비스에 대체 메서드를 추가한다
  * 초기에는 대체 메서드가 기존 저장 프로시저 역할을 대행한다
    * 다른 팀은 면밀한 테스트를 바탕으로 프로시저 호출부를 서비스로 대체한다
  * 이 기간동안 서비스와 저장 프로시저로 호출을 모두 지원한다
    * 피트니스 함수를 이용해 프로시저 호출이 모두 서비스 호출로 마이그레이션됐는지 확인한 다음 최종적으로 프로시저를 삭제할 수 있다
**교살자 무화과나무 패턴**

### 6.3.4 관계형에서 비관계형으로의 진화
* 많은 조직이 처음에는 모놀리식으로 서비스를 시작한다
  * 출시 시기, 단순성, 시장 불확실성에 대한 대응 등 여러 면에서 유리하다
  * 일반적으로 RDB로 구성
  * 이러한 모놀리식 아키텍처를 분해하는 작업은 퍼시스턴스 기능을 재고하기 좋은 기회다
  * 마이크로 서비스처럼 고도로 분산된 아키텍처의 장점 중 하나는 아키텍트가 필요에 따라 퍼시스턴스 메커니즘을 선택할 수 있다는 것이다

```markdown
진화적 아키텍처의 정의는 명백히 '다양한 차원'을 강조한다. 데이터는 아키텍처 외적인 영역에서 소프트웨어 시스템 진화에 가장 큰영향을 미치는
요소다. 경계 컨텍스트를 기반으로 아키텍처를 재구성하는 것은 곧 데이터의 분할을 의미하며, 이는 자체적인 트레이드오프를 동반한다
```