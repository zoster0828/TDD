# 아키텍처 실천
## 9.1 조직적 요인
* 소프트웨어 아키텍처는 소프트웨어와 관련이 없는 다양한 요소(팀 구조, 예산)에 걸쳐 광범위한 영향력을 펼친다

### 9.1.1 콘웨이의 법칙
* 사회적인 구조, 특히 사람들 사이의 의사소통 경로가 최종 제품 설계에 영향을 미친다
* 설계 초기는 각 책임 영역이 나뉘어지는 패턴을 깊이 이해하는 단계다
* 이 과정에서 집단이 문제를 나누는 방식은 향후 집단의 선택에 영향을 미친다
  * 하나의 큰 문제를 작게 나누어 위임하면 각각을 조정하는 문제가 다시 발생한다
  * 예를 들어 계층 아키텍처는 ui / business logic 등의 기술적 기능을 기준으로 계층을 나눈다
  * 이 구조에서 여러 계층을 관통하는 공통 요건을 처리하면 오히려 조정 오버헤드가 발생한다
    * 일반적인 계층형 팀 구조는 기술 계층과 아키텍처 계층이 유사할 경우 잘 동작하지만
    * 여기서 도메인 중심의 마이크로 서비스 구조의 아키텍처를 사용할 경우 오버헤드가 발생하게 된다
* `위임 영역이 분할되고 담당 범위가 좁아질 때마다 효과적인 설계 대안은 줄어든다`
* 작업을 분할하는 방식과 위임 범위를 항상 고민하고, 아키텍처의 목표와 팀 구조를 일치시키기 위해 노력해야 한다
* 이런 면에서 서비스 경계는 팀을 나누는 이상적인 기준이 된다
* 도메인을 중심으로 구성된 팀은 기술 중심 팀보다 진화적 아키텍처를 구현하기 유리하다

> 이정도의 조직 구조 변화를 아키텍트가 할 수 있나
> 
> c사에서 개발팀 리더가 와서 시도한 적이 있었지만 기획팀까지 변화 시킬 순 없었다

**교차기능팀(Cross functional team)**
* 도메인 중심 팀은 교차기능 팀인 경우가 많다
* 한 팀의 구성원만으로 제품의 모든 영역을 아우를 수 있다(PM / 기획 / 개발 / 운영)
* 이러한 팀에 포함된 각각의 역할을 알아보자
* 아키텍처
  * 아키텍처는 증분 변경을 방해하는 부적절한 커플링을 제거해야 한다
* 비즈니스 분석가
  * 도메인 영역의 복잡도가 높은 제품은 비즈니스 규칙, 설정, 제품 이력 등의 특성도복잡하고, 이런 제품은 BA의 조선이 반드시 필요한 전문 영역이다
* 데이터 팀
* 개발자
  * 풀스택!?
* 디자이너
  * 사용자와 대면하는 기능을 담당하며 일관적 인터페이스를 위해 다른 교차기능팀의 디자이너와 소통할 필요가 있다
* 운영
  * 전통적 조직에서 서비스 분할과 독립적 배포는 매우 어려운 과제다
  * 운영 프로세스가 성공적으로 안착하려면 시스템 프로비저닝, 배포 등의 자동화된 데브옵스 관행이 반드시 필요하다
* 제품 관리자(PM)
  * 고객의 니즈와 비즈니스 성과를 우선시한다
* 테스트
  * 테스터는 도메인 간 통합 테스트를 담당한다

* 교차기능팀의 목표 중 하나는 팀 조정 과정의 마찰을 근절하는 것이다
* 교차기능팀을 만들 자원이 없다면 한명이 여러개의 교차기능팀을 맡는다
  * > 그러면 되는건가? 그냥 안되는걸 억지로 하는것 아닌가?
* 교차기능팀의 구성원은 사일로 너머를 손가락질로 가리킬 필요가 없다
> 이런 형태의 조직인 회사가 있는지?
> 
> 서비스의 성공이 전체 조직의 성과로 이루어지지 않는다면(내부에서 다시 차등을 나눈다면) 무의미해지지 않을까? 하는 우려

**비즈니스 기능 중심 팀 구성**
* 도메인을 중심으로 팀을 구성하는 것은 비즈니스 기능을 중심으로 팀이 구성될 것임을 암시한다
* 기술 아키텍처가 고유한 복잡도와 추상화를 추구하는 한편 비즈니스 동작과는 느슨한 관계를 유지하기 바란다
* 이것은 전통적으로 아키텍트가 기능 위주로 아키텍처를 분할했기 때문이다
  * > 도메인 중심이라면 비즈니스 동작과 밀접해도 된다는 의미로 봐도 될지

**비즈니스 기능과 인지 부하의 균형**
* 스트림 정렬팀 : 도메인의 작업 흐름과 일치하는 팀
* 활성화팀 : 스트림 정렬팀에 새로운 기술/기법 습득을 지원하는 팀
* 난해한 하위시스템팀 : 도메인 최하단의 수학/계산/기술 분야를 담당하는 팀
* 플랫폼팀 : 스트림 정렬팀의 업무 속도를 가속시키기 위해 강력한 내부 도구를 생산하고 지원하는 팀
> 이 경우 보상은 스트림 / 난해한 하위시스템팀 으로 몰릴것 같음

**프로젝트를 넘어 제품으로**
* 전통적으로 소프트웨어 개발은 문제를 식별하고 개발팀을 구성하고 `완료`되면 프로젝트는 운영팀에 전달되고 유지보수 속에서 남은 여행을 보낸다
* 개발팀은 다음 문제를 해결하러 떠난다
* 여기서 발생하는 문제
  * 원래의 개발팀이 이동했기 때문에 유지 보수가 어려워진다
  * 개발자가 운영 업무로부터 격리되어 코드 품질을 등한시하기 쉽다
  * 프로젝트는 시간적 함의를 내포하므로 언젠가 종료된다는 인식이 있고 이것은 의사 결정에 영향을 미친다
* 이것을 프로젝트가 아닌 제품으로 인식한다면
  * 수명 주기가 없어진다
  * 제품의 소유자가 발생한다, 가치를 옹호하고 요구 사항을 반영할 수 있게 된다
  * 각 역할(PM, BA, 디자이너, 개발자..)의 역할이 뚜렷해진다
> study comment :  드릴 다운 팀 : poc 와 같이 끝까지 다 파고 들어가보는 팀이 있었는데
> 
> 문제는 본업 / 부업 (드릴이 부업인듯?)이다 보니 리소스 관리가 쉽지 않았고
> 
> poc 코드가 prd로 넘어가다보니 그게 잘 되진 않았다

**과도한 팀 규모 지양**
* 사람이 많아지면 단순히 N배 증가하는 것이 아니라 N(N-1)/2 만큼 의사소통을 위한 연결이 늘어나고 마찰이 강해진다

> study comment : 마이크로 서비스도 담당자가 있어야 책임감있게 기술부채도 처리하고 관리가 된다는 느낌을 받았다

### 9.1.2 문화
* 아키텍트는 엔지니어의 시스템 구축 과정을 살피고 조직의 보상 행동에 관심을 기울여야 한다
* 아키텍트가 도구를 선택하고 설계를 추진하는 의사 결정 과정은 소프트웨어가 진화를 감당하는 능력에 영향을 미친다
* 스스로 질문에 답하며 팀의 엔지니어링 문화를 이해해야 한다
  * 팀 구성원이 피트니스 함수를 알고 새로운 도구나 제품이 피트니스 함수 제작 역량에 미치는 영향을 고려하고 있는가? △
  * 피트니스 함수를 정의하고 시스템이 이를 얼마나 준수하고 있는지 측정하고 있는가? △
  * 응집도, 커플링, 동조성을 엔지니어가 이해하고 있는가? △
  * 도메인과 어울리는 기술 개념에 대해 대화를 나누고 있는가? O
  * 배우고 싶은 기술이 아닌, 변화에 적응하는 능력을 기준으로 솔루션을 선택하고 있는가? O
  * 비즈니스 변화에 팀은 어떻게 대응하고 있는가? 사소한 비즈니스 변화도 통합하기 어려워하거나 너무 많은 시간을 소비하지 않는가? O
* 팀은 주로 신기능 개발에 매진하며 보상 또한 이 분야에 집중된다.
* 코드 품질과 진화성은 의식적으로 우선시하지 않으면 간과될 가능성이 높다
* 진화적 아키텍처를 추구하는 아키텍트는 진화성을 높이는 설계를 우선시하는 팀에 주목하고 다른 팀에도 장려할 방법을 강구해야 한다

### 9.1.3 실험 문화
* 진화가 성공하려면 실험이 뒷받침 되어야 한다
* 실험이란 소소하지만 새로운 아이디어를 정기적으로 시도하는 활동이다
* 실험을 장려할 수 있는 방법을 알아보자
  * 외부 아이디어 도입
    * 외부 컨퍼런스를 통해 직원들이 새로운 기술, 도구, 접근 방식을 습득하도록 장려한다
  * 명시적 개선 장려
    * 도요타의 카이젠 문화, 모든 인원, 특히 문제와 가장 가깝거나 권한이 있는 인원은 지속적으로 개선을 추구해야 한다
  * 스파이크 구현 및 안정화
    * 스파이크 솔루션 : 난해한 기술 문제 학습, 미지의 영역 탐색, 예측 정확도 향상 등을 목표로 일회성 솔루션을 제작하는 XP 기법
    * 품질을 포기하고 학습 속도를 올린다. 우수한 설계가 아닌 빠른 학습속도에 중점을 둔다
  * 혁신 시간 확보
  * 집합 기반 개발
    * 다양한 접근 방법 탐색에 중점
    * 여러 조건을 탐색하는 과정에서 문제를 더 잘 이해하고 실질적 제약 조건이 드러난다
    * 짧은 시간 동안 여러 방식으로 프로토타입으 제작하고 상세한 데이터와 경험을 얻는다
  * 엔지니어와 최종 사용자 연결
    * 실험을 정확하게 하려면 작업의 영향력을 이해해야 한다
    * A/B 테스트, 파견(?)

### 9.1.4 CFO와 예산
* 전통적으로 예산을 책정하기 위해 소프트웨어 개발 생태계의 장기적 추세를 예측할 수 있어야 했지만 지금은 그렇지 않다
* 아키텍처 퀀텀의 수가 증가할수록 퀀텀당 비용은 적정 지점을 향해 하강한다
  * > 출처가 없음
* 퀀텀의 수가 증가할 때 비용이 감수하는 이유
  * 구성하는 요소가 작아지므로 관심사가 명확하게 분리 및 정의된다(불필요한 오버헤드 없어짐)
  * 퀀텀 수가 늘어날수록 운영은 자동화 되기 때문
* 그러나 퀀텀이 지나치게 작아지면 퀀텀의 규모 자체가 비용을 유발하기 시작함
* 아키텍트는 퀀텀 크기와 비용 사이에서 적정 지점을 찾아야 한다
  * 그리고 이것은 기업이 상대하는 시장에 차이가 있다
* 현대의 아키텍트는 진화적 시스템의 특성과 내재적 불확실성을 먼저 이해해야 한다

## 9.2 비즈니스 사례
* 지금까지 배운 맣은 사례들이 실질적인 비즈니스 가치를 만들지 못한다면 불필요한 메타워크가 될 뿐이다
* 아키텍트는 비즈니스 이해관계자가 이해하고 받아들일 수 있는 언어를 이용해 아키텍처의 개념을 설명할 수 있다
  * 예를 들면 A/B 테스트

### 9.2.1 가설 주도 개발 및 데이터 주도 개발
* 데이터 주도 개발은 데이터를 중심으로 기술적 변화를 도모하는 개발 방법론이다
* 가설 주도 개발은 기술 측면의 관심사 대신 비즈니스를 통합한다 - ?
  * 공식화된 요구 사항을 수집하고 애플리케이션 기능으로 구현하는 프로세스를 따르지 않는다
  * 과학적인 방법론에 시간과 자원을 투입한다
  * 예를들면 뭔가를 하고 싶어하는지보다 했을때 어떤지 가설을 세우고 A/B테스트를 통해 증명한다
  * > Business Driven Development 인듯한데, 가설은 어떻게 도출하는가
  * 프로젝트에 비즈니스 담당자가 관련되면 불안 요소가 점차 증가한다
    * 따로 떼어 놓고 보면 합리적이지만 기존 기능과 결합되면서 전반적인 경험 저하를 유발할 가능성이 있다

### 9.2.2 실험적 매체로서의 피트니스 함수
### `사례연구1` UDP 통신
* ETL과 모니터링 서비스 사이에 UDP를 사용하도록 설계했다
* 간혹 메시지가 누락되는 경우를 확인하기 위해 피트니스 함수를 구축하고 확인한다
* 사용된 가설은 다음과 같다 `모니터링 도구의 신뢰도가 제작자의 가정보다 낮을 것이다`
  * mock 서비스를 이용해 메시지를 발생해보고 확인하는 테스트를 작성한다

### `사례연구2` 보안 의존성
* PenultimateWidgets는 라이브러리 의존성으로 보안에 취약점이 발생한 적이 있다
* 이로 인해 기나긴 수동 프로세스가 추가되었고 팀의 발목을 잡는 요인이 되었다
* 이 시간을 줄이기 위해 파이프라인에 라이브러리 의존성 목록을 스캔하고 위험 라이브러리를 사용한 경우 실패 또는 경고하도록 한다

### `사례연구3` 동시 피트니스 함수
* PenultimateWidgets는 Strangler fig 패턴으로 하나씩 동작을 교체하며 개선해 부분 별 대응하는 마이크로 서비스를 만들어 냈다
* 예측한 임계 요청은 120건 이었으나 실제 가동 이후 반복적으로 중단되었고 측정 결과에 따르면서비스는 초당 300개의 요청을 처리하고 있었다
* 알고보니 1200 이었고 팀은 확장 임계치를 현실적인 수준으로 갱신했다.
* > 이미 들어오는 요청의 수를 정확히 파악 못한 것인지? 여기서 피트니스 함수의 역할이 무엇인지 이해가 잘 안됨

### `사례연구4` 정확성 피트니스 함수
* Strangler fig 패턴의 고질적인 문제는, 신규 시스템은 과연 기존 시스템을 완전히 대체하는가?
* 두개의 동작을 검증하는 시스템을 피트니스 함수로 도입하여 확인할 수 있다
* 피트니스 함수는 일관성을 보장하는 요소로 사용되었지만 그간 명시되지 않은 일부 유형의 데이터가 피트니스 함수를 통해 식별되었고 레거시의 이해도가 높아졌다
* > 실제로 똑같은 사례를 맞았는데
  > 
  > 기존 시스템을 대체하는 과정에서 두개의 결과를 비교하는 피트니스 함수를 만들고 검증해보니
  > 
  > 기존 시스템의 데이터가 오히려 더 적게 나온 경우가 있었음
  > 
  > 확인결과 기존 시스템의 누락으로 판단되어 기존 버전과의 비교 피트니스 함수에서 누락된 부분을 제외하고 확인하도록 수정하거나
  > 
  > 당장 대체가 어려운 부분인 경우 기존 시스템의 버그를 수정하고 다시 비교하는 방식으로 대체하였다

## 9.3 엔터프라이즈 피트니스 함수
### 9.3.1 `사례연구` 제로데이 보안 취약점
* 사용 중인 개발 프레임워크에서 제로데이 취약점이 발견되면 기업은 어떻게 대처할까
* 에퀴팩스의 사례
  * '대부분'의 취약점 모듈을 패치했으나 구형 시스템 중 다수가 제외되었고 결국 데이터 유출로 이어졌다
* 거버넌스가 자동화된 세계는 모든 프로젝트의 파이프라인에 보안팀이 피트니스 함수를 배포할 수 있는 슬롯이 있고 일상적인 안정장치 점검에 해당한다
* > git에 있는 credential guardian 같은 역할인듯
* 엔터프라이즈 아키텍트는 배포 파이프라인을 통해 전체 프로젝트에서 일관적인 테스트를 추진할 수 있다
* > git action의 flow chart에 mother chart를 도입하여 검증하는 사례로 볼 수 있을 것 같다
* 이러한 메커니즘은 핵심 거버넌스를 전역적으로 자동화한다

### 9.3.2 기존 통합 아키텍처의 경계 컨텍스트
* 계층 아키텍처는 프레젠테이션, 퍼시스턴스 등으로 컴포넌트가 구분된다
* 그러나 경계를 가로지르는 관심사에 대처하기 어렵다
* 관심사에 대응하는 DDD에 영감을 받은 아키텍처 모듈식 모놀리스와 마이크로 서비스로 변경하고자 하지만 서로 호환되지 않는다
* 그렇다면 어떻게 할 수 있을까?
  * 기술 계층 내부에 bounded context를 만든다
  * 여기서 bounded context를 보호하기 위함 피트니스 함수를 작성한다
> 예제와는 약간 다를 수 있지만 이번에 피트니스 함수를 프로젝트에 적용하면서
> 
> VM으로 구성된 기존 서비스 위에 요청량이 작은 서비스를 추가하기로 결정했음
> 
> k8s로 전환하면 아주 작은 pod로 구성할 수 있었지만 현재 그런 형태가 아니기 때문에 이미 구동되는 서비스에 추가하기로 결정하고
> 
> 오염과 추후 분리를 쉽게하기위한 package 규칙 위반을 검사하는 피트니스 함수를 적용했음

## 9.4 시작 지점
### 9.4.1 낮게 매달린 과일
* 먼저 초반의 소소한 성공 사례가 필요하다.
* 이미 분리되어 있으며 주요 의존성 경로에서 벗어난 구성 요소가 적당하다
* 모듈성 증가와 커플링 감소를 이끌어내는 과정에서 진화적 아키텍처만의 특성인 피트니스 함수와 증분 변경 기술을 시연할 수 있다
* 구체적인 데이터는 개발자의 방법론을 심사하는 가장 좋은 근거 자료가 된다
* 회의적인 문화 속에서 진화적 아키텍처의 가능성을 조금이나마 엿보고 싶은 경우에 추천한다

### 9.4.2 최대 가치 우선
* 가치가 클 수록 아키텍트에게 헌신을 강조하는 효과
* 가장 가치가 높은 부분을 먼저 선택함으로써 진화적 아키텍처의 장기적인 가치를 가늠
* 개념을 증명하고 향후 진행 여부를 결정

### 9.4.3 테스트
* 테스트는 진화적 아키텍처의 증분 변경에 중요한 컴포넌트 이며 피트니스 함수는 테스트를 적극적으로 활용한다
* 테스트가 포괄적일수록 지화적 아키텍처의 구현이 용이하다

### 9.4.4 인프라스트럭처
* 인프라에 결함이 있다면 진화적 아키텍처보다 이 문제를 먼저 잡아야 한다
* 인프라 기능 장애는 개발과 운영 사이의 극복 불가능한 장볍이 된다
* 기술 부채는 인프라 내부에 축적된다

### 9.4.5 `사례연구` PenultimateWidgets의 엔터프라이즈 아키텍처
* Penultimate팀은 레거시의 주요 부분을 개편하기에 앞서 신규 플랫폼의 요구되는 속성을 나열했다
* 문제는 프로젝트에서 이러한 속성을 일일이 검증할 수 있는가
* 시스템의 모든 부분에 이러한 속성이 적용되는 것이 맞는가
* 오버헤드가 너무 크다
* 피트니스 함수로 기준을 정의하고 핵심 기능을 확인하는 피트니스 함수를 파이프라인 내부에 두고 서비스용 피트니스 함수는 개별 팀의 몫으로 남겨두었다

## 9.5 미래 전망
### 9.5.1 AI를 활용한 피트니스 함수
* 비정상적인 동작을 감지하는 AI 기반 피트니스 함수
* AI를 이용한 휴리스틱을 구현하고 트랜잭션을 감지한다

### 9.5.2 생성 테스트
* 개발자가 대량의 테스트를 실행하고 결과를 수집하고 통계와 분석을 이용해 이상 행동을 발견한다
* 생성 테스트는 가능한 모든 값을 대입하고 문제가 발생한 경계 조건을 보고한다
* > 인코딩 test에 랜덤값을 넣는 경우와 유사해보임

## 9.6 되는 이유와 안 되는 이유
### 9.6.1 기업이 진화적 아키텍처를 구축하는 이유
* 예측성 vs 진화성
* 확장성
* 고급 비즈니스 기능
* 비즈니스 지표로서의 순환 주기
* 퀀텀 수준의 아키텍처 특성 격리
* 적응 vs 진화
### 9.6.2 기업이 진화적 아키텍처를 구축하지 않는 이유
* 커다란 진흙 공
* 지배적인 아키텍처 특성
* 희생적 아키텍처
* 폐업 예정 비즈니스


> 담당자 시스템이 없다면 데이터에 대한 분석이 약해지지 않을까? 약한 오너십이 가지는 문제
> 
> 실제로 이런 문제가 있는 것 같다. 깊이를 가지기 어려움
> 
> 장애가 있을때 뭔가 고인문들 위주로만 보게 되었다. 팀이 나눠지고 나서는 각자 자기 모듈에 대한 애정이 생긴다
> 
> 개발은 다같이 하고 운영 담당자를 만든다

> 깃액션 / 젠킨스 차이 : 
> 
> 러너에 대한 확장성
> 
> 스크립트가 코드로 관리되고 같은 레포에 존재한다
>
> 깃 액션 플러그인
> 
> 태그를 쓰는 이유 : 뭐가 나갔다 이런 장점