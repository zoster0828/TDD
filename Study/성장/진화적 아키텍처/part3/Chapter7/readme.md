# 진화 가능한 아키텍처 구축
* 개발 효율성은 그 자체로 가치 있는 목표지만 우리는 여기에 그치지 않고 다음 단계를 향해 나아가야 한다
* 실제 세계와 함께 진화하는 아키텍처를 신규 프로젝트에 적용하려면 어떻게 해야 하는가

## 7.1 진화적 아키텍처의 원리
### 7.1.1 책임이 따르는 마지막 순간
* 중요한 결정은 가능한 한 미루고 더 이상 미룰 수 없는 시점을 넘겨선 안 된다
* 성급하면 over engineering, 적시를 놓치면 아키텍처의 목표를 가로 막는다

### 7.1.2 진화성을 높이는 설계 및 개발
* 아키텍트는 진화성을 아키텍처의 최우선 목표로 여겨야 한다
* 커플링의 적합성을 고려하고 아키텍처의 취약점을 보완할 수단을 강구해야 한다

### 7.1.3 포스텔의 법칙
* 자신의 것은 보수적으로 하달하라
  * 커플링 지점은 계약정보를 최대한 이용하려 하므로 필요한 것만 전달한다
* 다른 이의 것은 관대하게 수용하라
  * 추가 데이터가 있다 해도 꼭 필요한 정보만 사용하면 된다
* 계약을 해제할 때는 버전을 관리하라

### 7.1.4 테스트성과 아키텍트
* 아키텍처를 설계하며 테스트성을 우선적으로 고려하는 경우는 많지 않다
* 테스트하기 용이한 아키텍처의 대표적 특성은 SRP 준수다
* 서로 다른 관심사가 뒤섞이면 각각의 동작을 독립적으로 테스트하기 어렵다

### 7.1.5 콘웨이의 법칙
* 의외로 조직과 팀의 구조 또한 커플링이 발생하는 지점이다

## 7.2 역학
### 7.2.1 [1단계]진화의 영향을 받는 차원 식별
* 아키텍트는 아키텍처가 진화하는 동안 보호해야 할 아키텍처 차원을 식별해야 한다
* 식별 과정은 반드시 각 특성에 관련된 팀과 함께 진행해야 한다

### 7.2.2 [2단계] 각 차원의 피트니스 함수 정의
* 하나의 차원에 여러 피트니스 함수가 있는 경우도 있다
* 아키텍트는 다양한 코드 메트릭을 배포 파이프라인에서 활용한다
* 지속적으로 관리할 차원을 선별하고 위키 등의 간단한 양식을 이용해 문서화 한다

### 7.2.3 [3단계] 배포 파이프라인을 이용한 피트니스 함수 자동화
* 변화가 증분 변경으로 진행되게 권장해야 한다
* 증분 변경은 진화적 아키텍처에 동력을 공급하는 엔진이다
  * 배포 파이프라인에서 피트니스 함수를 통해 선제적 검증
* 순환 주기는 증분 변경의 효과를 잘 드러내고 다양한 지표를 파생시킨다
* 개발 과정에서 문제의 조짐이 보일때 피트니스 함수를 구축해두면 확산을 방지할 수 있다

## 7.3 그린필드 프로젝트
* 신규 프로젝트에 진화성을 구축해두면 기존 프로젝트 개선보다 쉽다
* 시작 단계에 미리 구축해두면 증분 방식으로 변경을 적용할 수 있다
* 기존 프로젝트 개선은 이미 존재하는 커플링을 해체해야 하는 어려움이 있다

## 7.4 기존 아키텍처 개조

### 7.4.1 커플링과 응집도
* 아키텍트는 기술적 커플링뿐만 아니라 시스템 컴포넌트의 기능적 응집도를 방어해야 한다
  * 컴포넌트의 크기를 문제 컨텍스트에 적합하게 유지한다는 의미
* 지속적 통합을 이루어 냈어도 테스트를 수동으로 진행하는 경우도 많다
  * 실행 주기에서 손해가 있더라도 배포 파이프라인에 포함시키면 피드백의 선순환을 일으키고 개선 의욕을 고취시킨다
* 진화적 아키텍처 구축의 가장 큰 장애물은 운영의 어려움이다
  * 변경사항을 손쉽게 배포할 수 있는 환경이 아니라면 피드백 주기 전체에 지장이 생긴다
* 모든 아키텍처 검증을 피트니스 함수로 구현하면 유익한 시너지를 내는 각종 상호작용을 한층 일관성 있게 정의할 수 있다

### 7.4.2 상용 소프트웨어(COTS)
* 일반적으로 상용 소프트웨어는 진화를 지원하지 못하는 경우가 많다
* 아래 요구사항들이 충족되지 않기 때문
  * 증분 변경
  * 적정 커플링
  * 피트니스 함수

## 7.5 아키텍처 마이그레이션
* 많은 시니어 개발자는 동일한 유형의 애플리케이션을 반복적으로 구축하는 것에 지루해한다
* 프레임워크를 사용해 쓸모있는 것을 만드는 것보다 직접 만드는 것을 더 선호한다
* 인프라를 직접 만들기 시작하고 오픈소스가 뒤늦게 등장했을때 표준화 해야 했지만 고수했다
* 인프라를 구축한 최고의 개발자들은 유지보수 업무에 투입되어 잡무를 수행한다
> 예시가 부적절하다
* 흥미로운 일이나 경력을 돋보이게 할 작업에 이끌리는 것은 아키텍트도 별반 다르지 않다
* 구현을 위한 구현이라는 함정에 빠지지 말자

> 첫째 이후에 둘째가 잘 등장하지 않는 책 ㅡㅡ...

### 7.5.1 마이그레이션 단계
* 모놀리식 애플리케이션을 현대적인 서비스 기반 애플리케이션으로 전환한다면
* 먼저 커플링 지점을 분석하고 해체한다
  * 마이크로 서비스에서는 데이터 베이스가 BOUNDED CONTEXT 내부에 존재해야 한다
  * 클래스는 원하는 만큼 나눌 수 있지만 트랜잭션을 분할하는 것은 불가능한 경우가 많다
* 모놀리식 서비스를 아래 기준에 따라 분할해 보자
  * 비즈니스 기능 그룹 : 기능을 그대로 본떠 명확하게 구역을 나눈다, 통신 계층 구조를 모방하는 소프트웨어 구축은 콘웨이의 법칙을 현실에 적용한 예이다
  * 트랜잭션 경계 : 엄격한 트랜잭션 경계를 준수해야 하는 비즈니스도 많다
  * 배포 목표 : 증분을 통해 각기 다른 일정으로 선택적 릴리즈를 할 수 있다, 이런 운영적 기준으로 서비스를 분할하려면 기준의 중요도가 높아야 한다
    * 확장성이 극단적으로 중요한 시스템도 비슷한 경우로 볼 수 있다
* 서비스의 규모가 커질수록 마이크로 서비스의 운영 난도가 높아지는 경향이 있다
  * 트레이드 오프다!

> 마이크로 서비스로 분할할때 명확한 BOUNDED CONTEXT를 두듯이 서비스 전체에도 BOUNDED CONTEXT를 두고 분할하면 어떨까
> 
> 예를들어 게시판 서비스라고 할 때 MEDIA 저장 기능을 하나의 BOUNDED CONTEXT로 3rd 파티처럼 운영한다면
> 
> 조직이 같다면 개념적으로 분리해도 결국 커플링이 생길것 같긴 하다(콘웨이의 법칙)

### 7.5.2 모듈 상호작용의 진화
* 공유 모듈과 컴포넌트는 마이그레이션 과정에서 개발자가 자주 마주치는 장애물이다
* 공유 라이브러리가 있는 모듈을 별도 서비스로 분리할때 이 의존성이 유지될 수 있을까?
  * 공유 라이브러리의 각 기능이 모두 필요하지 않다면 라이브러리를 분리할 수 있다
  * 그렇지 않다면
    * jar를 만들어서 공유한다
    * 메시징 또는 서비스 호출을 통해 분리한다
> 큰 틀에서 봤을때 동일하지 않을까
> 
> gradle을 사용한다면 공유 라이브러리의 의존성을 항상 latest로 해놓으면 배포할때마다 최신 버전으로 실행될 것
> 
> 배포 주기가 길어졌을때 문제가 될 수 있지 않을까 싶지만 라이브러리에서 하위호환을 지원하면 동일한 얘기가 될 것 같다
> 
> 이전장의 확장/수축

## 7.6 진화적 아키텍처 구축 가이드라인
* 진화는 핵심 메커니즘을 교체하기보다 새로운 계층을 쌓아 올리며 진행된다
* 거대한 진흙 공을 마이크로서비스 아키텍처로 빚어내는 것은 쉽지 않다
* 전체 아키텍처를 교체하지 않고 진화성을 높이는 방법을 알아보자
### 7.6.1 불필요한 변동성 제거
* 현대의 데브옵스는 눈송이(snowflake)를 불변(immutable) 인프라로 대체하는 방식으로 동적 균형 문제를 해결했다
* 눈송이는 손수 제작한 자산이며 모든 유지 관리 작업이 수작업이라는 의미이다
* 불변은 프로그래밍 방식으로 정의된 시스템이다. 소스코드를 통해 반영되고 실행 중인 운영체제는 수정하지 않는다
> VO?
* 이것은 진화와 대척점에 있는 것 처럼 들리지만 사실은 반대다
* 불필요한 변수를 제거하고 시스템을 예측 가능한 상태로 만들고 끊임없이 변경하고 발전시킨다
  * 심지어 개발 환경 마저도
> 페어 워크를 많이 하다보면 자연스럽게 팀원들의 개발환경이 비슷해지는 경향성이 있다

### 7.6.2 결정과 번복
* 예상 못한 방법으로 실패 했을때 되돌리려면?
  * 블루/그린 배포
    * 그린을 배포하고 문제가 발생하면 즉시 백업본인 블루로 돌아간다
  * 기능 토글
    * 기능을 토글할 수 있도록 세팅하고 토글을 통해 확인후 문제 발생시 즉시 토글하여 되돌린다
> 롤백이 불가능한 배포인 경우 어떻게 하는지 궁금
>
> 팀에서는 배포 하기전에 롤백이 즉시 가능한 배포인지 체크하는 단계가 있음
> 
> 롤백이 불가능한 배포라면 조금 손이 가더라도 가능한 형태로 변경하도록 함
> 
> 그래도 안되면 PDD로 배포한다


### 7.6.3 예측성과 진화성
* 안다는 것을 아는 것
* 모른다는 것을 아는 것
* 모른다는 것조차 모르는 것
* 변화로부터 자신을 격리하기 위해 손상방지 계층의 구축이 필요하다

### 7.6.4 손상방지 계층 구축
* 프로젝트가 외부 라이브러리와 과하게 엮여있는데 변경되었다면?
  * 외부 라이브러리와 애플리케이션의 결합 지점은 추상화 하는것이 좋겠다
  * 이 모드것은 트레이드 오프에 대한 올바른 이해에 달려 있다
```JAVA
class CustomerAdapter {
    public static NewCustomer convertToNewCustomer(LegacyCustomer legacyCustomer) {
        String[] names = legacyCustomer.getFullName().split(" ", 2);
        String firstName = names[0];
        String lastName = names.length > 1 ? names[1] : "";
        return new NewCustomer(firstName, lastName, legacyCustomer.getEmail());
    }

    public static LegacyCustomer convertToLegacyCustomer(NewCustomer newCustomer) {
        String fullName = newCustomer.getFirstName() + " " + newCustomer.getLastName();
        return new LegacyCustomer(fullName.trim(), newCustomer.getEmail());
    }
}

// 사용 예
public class AntiCorruptionLayerExample {
    public static void main(String[] args) {
        // 레거시 시스템의 고객 데이터
        LegacyCustomer legacyCustomer = new LegacyCustomer("John Doe", "johndoe@example.com");

        // 손상 방지 계층을 통한 변환
        NewCustomer newCustomer = CustomerAdapter.convertToNewCustomer(legacyCustomer);

        // 변환된 새 시스템의 고객 데이터 확인
        System.out.println("First Name: " + newCustomer.getFirstName());
        System.out.println("Last Name: " + newCustomer.getLastName());
        System.out.println("Email: " + newCustomer.getEmail());
    }
}
```
* 필요할 것 같아 미리 만들지 말자(YAGNI), 강한 결합이 생길 뿐이다
* 모든 것을 추상화 하라는 이야기는 아니다. 현대의 IDE는 필요할때 추상화를 할 수 있는 쉬운 기능을 제공한다

### 7.6.5 희생적 아키텍처 구축
* 프레드 브룩스는 `맨먼스 미신`에서 새로운 시스템을 구축할때 **버리기 위한 계획**을 세우라고 조언한다
* 시스템을 구축하면 그전에 몰랐던 미지의 문제에 대해 알게 되고 불확실했던 아키텍처 결정을 내릴 수 있게 된다는 것
* `성공적으로 개념을 입증한 다음 버려지도록 설계된 아키텍처` : 희생적 아키텍처
* eBay나 twitter(X)도 이러한 전략을 통해 시장을 선점할 수 있었다

### 7.6.6 외부 변화 경감
### 7.6.7 라이브러리 vs 프레임워크
* 라이브러리는 비교적 더 실용적이고 프레임워크는 여러 기능을 많이 가지고 있는 경우가 많다
* 프레임워크의 메이저 업데이트를 두 번 이상 미룬다면 반드시 댓가를 치르게 될 것
* 이러한 차이로 프레임 워크는 푸시, 라이브러리 업데이트는 폴 방식으로 처리하는 것이 좋다

### 7.6.8 서비스 버전 내재화
* 버저닝을 통해 변화를 추적한다
* 버전 번호 방식과 내부 응답 방식으로 나눌 수 있음 
  * 버전 : 사용자가 찾아서 버전에 따라 호출하는 방식
  * 내부 응답 : 호출 받는 곳에서 컨텍스트를 보고 엔드포인트 할당

### 7.6.9 PenultimateWidgets 별점 서비스의 진화

### 7.7 피트니스 함수 주도 아키텍처
* TDD처럼 아키텍처도 비슷한 프로세스를 적용할 수 있다
  * 이번에 해봤는데 좋았음!
* LMAX 팀에서는 먼저 피트니스 함수를 구축하고 실험적 설계를 했다
  * 원하는 수준에 미치지 못하자 입력 및 출력 디스럽터 아키텍처 패턴을 설계했다

```markdown
도메인과 기술의 다양한 변화를 견디는 시스템을 구축하려면 피트니스 함수를 구축하고 계약을 통해
커플링을 제어해야 한다.
이를 통해 중요한 사안에 대해 빠른 피드백을 제공할 수 있다
진화적 아키텍처는 여러 변화 요인을 통제하고 올바로 작동한다는 확신을 준다
```