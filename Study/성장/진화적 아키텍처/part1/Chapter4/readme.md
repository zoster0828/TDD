# 아키텍처 거버넌스 자동화
* 전통적으로 거버넌스 집행은 코드 리뷰, 검토 위원회 등의 비효율 적인 수단 뿐이었다
* 그러나 자동화된 피트니스 함수의 등장으로 새로운 능력을 얻게 되었다
* 이를 이용해 SW를 발전 시키고 자동화된 거버넌스 정책을 수립하는 방법을 알아보자

## 4.1 피트니스 함수와 아키텍처 거버넌스
* 피트니스 함수를 CI와 결부시킴으로 아키텍트는 메트릭과 거버넌스 검사를 정기적인 무결성
검증 절차를 만들 수 있다
* 통합과 데브옵스에 점진적 변화를 적용하듯 아키텍처 거번넌스에도 동일한 개념을 적용할 수 있다

## 4.2 코드 기반 피트니스 함수
* 아키텍처의 흥미로운 특성을 드러내는 메트릭을 알아보자
### 4.2.1 구심 및 원심 커플링
* 구심 커플링 : 코드로 오는 수신 연결 수 측정
* 원심 커플링 : 다른 코드로 나가는 발신 연결 수 측정
* 강한 커플링은 하나의 변경 사항이 다른 수많은 컴포넌트로 파급되게 한다

> 아주 강한 커플링이 만들어지면
> 
> 이 모듈이 왜 분리되었는지조차 알 수 없게 된다

### 4.2.2 추상도, 불안정도, 메인 시퀀스와의 거리
* 추상도 A: abstract : implement의 척도
  * abstract / (implement + abstract)
  * 1에 가까울 수록 좋다
  * 만줄짜리 main 함수로 구성된 프로그램은 0에 수렴
* 불안정도 I: 원심과 구심 커플링의 합에 대한 원심의 비율
  * 원심 / (원심 + 구심)
  * 1에 가까울 수록 불안정 0에 가까울수록 안정적 또는 경직적
* 두개의 값은 별개로 취급하지 말고 함께 고려하는 것이 좋다

---
* 주계열과의 정규화된 거리 : D = |A + I - 1|
  * https://en.wikipedia.org/wiki/Software_package_metrics
  * 선에 가까울 수록 균형이 잘 잡혔다고 판단
  * 추상도와 불안정도가 모두 1이라면 무용의 영역 모두 0이라면 고통의 영역이다
  * Ndepend로 분석해보자
> 빨리 해봐야 될 것 같음
> 
> 리팩토링의 성공여부를 판단할 수 있는 객관화된 지표 중 하나로 사용하면 좋을 것 같다

### 4.2.3 임포트 방향성
* JDepend를 통해 커플링 특성을 분석할 수 있다
  * Java로 작성되어 단위 테스트에 분석 과정을 통합할 수 있는 장점도 있다
* 이것은 질책을 낳는 엄격한 개발 지침이 아닌 아키텍처 보호를 위한 조치이다
* 구조적 문제보다 도메인에 더욱 집중 할 수 있게 해준다

> 결국은 좋은 소프트웨어는 도메인의 문제를 잘 해결한 것이며
> 
> 이 과정에서 발생하는 좋은 구조와 코드는 쉬운 유지보수를 위한 수단이다
>
> 때때로 코드의 예술가로 빠져들게 되는데 조심하는것이 좋겠다

### 4.2.4 순환 복잡도와 '군집' 거버넌스
* 순환 복잡도는 공통적인 코드 메트릭이며 함수 또는 메서드 복잡도를 측정하는 수단이다
  * 명확하게 측정할 수 있으며 순환 복잡도 메트릭으로 정의할 수 있다
  * 단일 함수의 순환 복잡도를 계산하는 공식은 CC = E - N + 2
    * E는 edge 가능한 결정의 가짓수 N은 노드로 결정이 발생한 코드 라인 수
    * 적절한 값은 상황에 따라 다르나 10 이하여야 하며 5미만을 목표로 한다
    * Crap4j로 CC를 측정할 수 있다
    * TDD는 테스트를 만들기 위해 더 작고 덜 복잡한 메서드를 유도하는 측면이 있다
* 피트니스 함수를 통해 이미 CC가 10이 넘어버린 프로젝트여도 점진적으로 해결해나갈 시간을 얻도록 할 수 있다
> 무시해버리진 않을까?
* 이처럼 거버넌스를 통해 비트 부패를 방지할 수 있게 된다

## 4.3 턴키 도구
### 4.3.1 오픈 소스 라이브러리의 적법성
* 만약 오픈소스 라이브러리가 사용한 프로젝트에도 같은 라이선스를 채택하도록 요구한다면?
* 그리고 이것을 막으려면 어떻게 해야 할까
  * 아키텍트는 먼저 이러한 도구가 있는지 확인한다
    * Black duck
  * 도구가 없다면 피트니스 함수를 구축해서 막아보자
    1. 오픈 소스 다운로드 패키지 내부의 라이선스 파일을 확인하고 DB에 기록한다
    2. 라이선스 파일의 전체 내용 또는 해시를 라이브러리 버전과 함께 저장
    3. 버전이 변경되면 라이선스 파일을 검색하고 현재 버전과 비교
    4. 해시가 일치하지 않으면 변호사에게 통보
  * 자동 + 수동화된 피트니스 함수를 통해 막을 수 있다

### 4.3.2 접근성 및 기타 아키텍처 특성
* A11y : accessibility 를 기업 / 정부 기관이 요구 조건으로 내세우면서 접근성 검증 도구도 주목 받고 있다
> k8s?
### 4.3.3 ArchUnit
* 컴포넌트/Class 의존성 또한 아키텍트의 일반적인 관리 대상이다
  * Archunit을 통해 액세스 허용 및 제한을 컴파일 시점에 제어할 수 있다
> 현재 회사 프로젝트에서 package 간 의존성을 관리할 때 단순히 search를 통해
> 
> 주기적으로 체크하고 있는데(미래엔 분리할 예정이므로)
> 
> 해당 test를 추가해서 검사해보면 좋을 것 같음
>
> class의 경우 수많은 클래스를 그럼 이걸 다 테스트 해서 막아야 하나? 의문
* 상속 검사 : 상속 클래스의 이름을 제한할 수 있다
* 어노테이션 검사 : 사용하는 클래스에 특정 어노테이션이 존재하는지도 검사 할 수 있음
* 계층 검사
  * 아키텍트가 특정 관심사를 분리하기로 결정하면 개발자는 종종 번거로운 상황에 처한다
  * 장기적으로 보면 진화와 격리 측면에 이득이 된다
  * 특정 계층과 그에 다른 접근 규칙을 정의할 수 있다
    * 여러 문서로 원칙과 예시를 기록해 두지만 이를 읽는 사람은 거의 없다
    * 원칙을 표현하는 습관은 많은 도움이 되지만 실행이 뒤따르기 어렵다
    * 피트니스 함수를 통해 유효성을 검증하고 개발자가 원칙을 따르도록 하자

### 4.3.4 코드 거버넌스와 린터
* ArchUnit과 동일 선상에 놓을 만한 도구는 드물지만 대부분은 린터를 가지고 있다
* 이러한 도구들을 활용해 코드베이스의 구조 규칙을 코드화할 수 있다

### 4.3.5 가용성 피트니스 함수
* ?
### 4.3.6 카나리아 릴리스와 부하 테스트
* 부하를 견딜 수 있는 시스템인지 확인
* 카나리아 릴리스로 일부 사용자들의 요청이 카나리아로 전달 
* 모니터링 결과 문제가 없었으면 점차 대상을 확대해 나간다

### 4.3.7 이식 원칙
* 가장 많이 사용하는 기능은 무엇인가?
* 레거시에 로깅을 추가해 실제로 사용한 메뉴를 추적
* 확인 결과 그간 많은 노력을 기울여 구축했던 일부 기능은 거의 사용되고 있지 않았음
* 새 서비스에서는 해당 기능을 제외하기로 결정함

### 4.3.8 이미 사용 중인 피트니스 함수
* 피트니스 함수 개념이 주는 통찰 다양한 도구를 하나의 관점으로 통합하는 사고 방식을 이끈다
* 피트니스 함수를 이미 사용하고 있더라도 그것을 피트니스 함수라 부르지 않고 있을 가능성이 높다
  * 린트, 소나큐브 등도 모드 피트니스 함수 도구다
* 단순한 모니터링 메트릭이 피트니스 함수는 아니며 객관적인 척도에 경고와 알림을 접목해야 피트니스 함수가 된다
* 서로 긴밀하게 엮어 지속적으로 검증해야 한다

## 4.4 통합 아키텍처
### 4.4.1 마이크로서비스의 통신 거버넌스
* 마이크로서비스에 적용할 수 있는 턴키 도구는 없다
  * 각기 다른 기술, 프로토콜 등을 가지기 때문
* 하지만 전체를 직접 만들필욘 없다, 약간의 접착제로 피트니스 함수를 이어 붙이면 된다
* 서비스 간 통신을 확인하는 2가지 피트니스 함수가 있다
  * 24시간의 로그를 모아 확인하는 방식
  * 즉시 확인하는 방식
  * 각각의 장단점은 런타임 오버헤드 vs 빠른 위반 확인
  * 거버넌스의 목적에 따라 결정하면 된다

### 4.4.2 피트니스 함수 구현 방법 선택
* 메시지의 누락을 확인하는 피트니스 함수가 필요하다면
  * 수/발신 메시지의 개수를 확인하고 경보를 발생하는 방법
  * 메시지에 ID를 부여하고 각 메시지가 완료되었는지 확인하는 방법
  * 쉽지만 완벽하진 않은 방법 vs 어렵지만 완벽한 방법
  * 어디에 중점을 둘 것인지에 따라 결정

## 4.5 데브옵스
* 데브옵스 접점의 피트니스 함수가 필요한 이유
  1. 피트니스 함수는 아키텍처와 운영의 교차 지점에 있다
  2. 피트니스 함수는 객관적인 거버넌스 점검 결과를 드러내기 때문
* 카오스 엔지니어링
  * 카오스 멍키 : 잠입 해 예측 불가한 사건 생성
  * 카오스 고릴라 : 데이터 센터 전체 장애
  * 카오스 콩 : 클라우드 생태계가 완전히 사라진 것 같은 상황
  * 닥터 멍키 : 시스템 메트릭 알림
  * 레이턴시 멍키 : 카오스 멍키의 레이턴시 결함 강조 버전
  * 적합성 멍키 : 특정 거버넌스 피트니스 함수를 구현
  * 보안 멍키 : 보안에 초점을 맞춘 요소 검색

## 4.6 엔터프라이즈 아키텍처
* 아키텍처의 추상화를 통해 조직의 문제 해결 방법을 플랫폼 뒷편으로 감춘다
* API는 일관적이며 변경 주기가 길고, 구현 커플링의 확산을 늦춰 결과적으로 아키텍처의 취약성을 낮춘다
* 이러한 요소들로 인해 기술적인 선택에서 벗어날 수 있는 이점도 누리게 된다
  * 피트니스 함수를 통해 플랫폼 수준에서 구체적인 피트니스 함수를 정의할 수 있고
  * 전략적 비전을 관리할 수 있다

### 4.6.1 일간 60회 배포와 아키텍처 재구성
* 깃헙은 핵심 기능을 대체하기 위해 Scientist를 제작했다
  * 사용자의 1%는 새로운 기능을 시도한다, 시도와 관계없이 항상 구버전의 결과를 반환한다
  * 실행 순서나 기타 부수적인 요인은 False-Positive를 만들 수 있다, 순서를 무작위로 지정해 오류의 가능성을 줄인다
  * A/B 테스트를 지원하므로 성능을 모니터링 한다
  * 각 호출 결과를 비교하고 차이점을 기록한다
  * 신규 기능에 대한 모든 예외를 감추고 개발자가 분석하도록 기록한다
  * 모든 데이터를 다양한 형식으로 제공한다
> 현재 비슷한 기능을 구현하고 있는데(기텁처럼 아름답진 않다)
>
> 신/구 서비스의 차이를 기록하는 script를 만들고
> 
> 신/구 서비스에 모두 요청을 날림
> 
> script를 수행해 신/구 서비스에서 차이로 true/false 반환
> 
> 2주 정도 테스트할 예정인데, Scientist 처럼 동작하게 proxy를 두고 처리했으면 좋았을 것 같다
### 4.6.2 정확성 피트니스 함수
* Scientist는 정확성 피트니스 함수라는 검증 유형을 구현한다
* 정확성 피트니스 함수를 이용하면 구형과 신형 시스템을 나란히 비교할 수 있다

## 4.7 피트니스 함수는 무기가 아닌 체크리스트다
* 피트니스 함수는 아키텍트가 개발자를 공격하고 괴롭히는 무기처럼 보일때도 있다
* 그러나 이것은 본질이 아니다
* 피트니스 함수는 아키텍처 원칙을 시행할 방법을 제시해야 한다
* 위키나 지식 공유 포털을 통해 아키텍처와 설계 원칙을 명시하지만 실행되지 않는 원칙은
일정의 압박과 여러 제약 조건 속에서 유명무실 해진다
* 아키텍처 설계 원칙과 거버넌스 규칙을 피트니스 함수로 변환하면 외부의 압력이 작용해도 생략되거나 건너뛰지 않도록 절차를 보장할 수 있다
> 하나의 프로젝트에 여러 유사한 서비스를 package로 분리하여 작성하고 있는데
> 
> 이후 분리를 쉽게 하기 위해 package 간의 호출을 하지 않도록 가이드하고 있음
> 
> 그러나 종종 PR에서 utility 클래스나 유사한 클래스를 의도적으로 또는 자신도 모르게 호출하는 케이스가 발견됨
> 
> 수동 리뷰를 통해 잡고 있지만 일단 pr은 보내고 이후 task 생성하여 처리하는 경우도 있음
> 
> 피트니스 함수를 통해 원천 차단하는게 좋아보임

## 4.8 피트니스 함수 문서화
* 아키텍처 결정을 문서화할 때는 ADR을 참고하면 좋다
  * 아무리 유려하게 작성된 피트니스 함수라도 기술자가 아닌 사람이 읽기 어렵기 때문
* Cucumber와 같은 프레임워크를 사용하는것도 좋다
* 가급적 조직 내 문서 프레임워크에 피트니스 함수 정의를 통합하자
  * 가장 일관적인 방식으로 접근하는 것이 효과적이기 때문이다
  * 피트니스 함수의 최우선 가치는 실행이지만, 이해 가능성도 그에 못지 않다

---
* 피트니스 함수는 가드레일이다
  * 도로는 아스팔트, 조약돌, 자갈등으로 만들어진다
  * 가드레일은 차량이나 도로의 종류와 관계없이 여행자가 도로밖으로 떨어지지 않게 하기 위해 존재한다.
