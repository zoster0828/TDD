# 진화적 소프트웨어 아키텍처
### 두 가지 진화 가능한 근본 원리
1. 애자일에서 확립된 효과적인 엔지니어링
2. 변화와 거버넌스를 촉진하는 아키텍처

## 1.1 진화적 소프트웨어의 과제
* 비트 부패, S/W 부패, 코드 부패, S/W 부식, S/W 붕개, S/W 엔트로피
  * 시간이 지남에 따라 S/W 품질이 서서히 저하되거나 응답성이 감소해 S/W 결함을 일으키는 변화
> 아무런 배포나 변경사항이 없었던 시스템임에도 시간이 지남에 따라 성능이 떨어지거나, 사용이 불가능해진 경우가 있었음
> 
> 플랫폼의 또는 데이터량의 변화에 따라, 결론적으로 S/W도 관리하지 않으면 유기물과 같이 시간이 지남에 따라 부패하게 됨

* 소프트웨어 생태계는 많은 도구, 프레임워크 라이브러리 등으로 구성되며 동적인 균형을 이룬다. 계속해서 새로운 것들이 나타나서
기존의 균형을 무너뜨리고 새로운 균형을 만들어낸다.
* C/D는 고립되어 있던 운영을 개발 라이프사이클에 통합시킴으로 변화에 대한 새로운 관점을 열었다
* 이러한 파괴적 변화는 예측하기 어렵다. 도커 컨테이너 기술의 급부상은 예측할 수 없는 변화의 실례다
  * 과거 OS, 서버, 인프라 등에 막대한 비용이 들었다 
  * 시간이 변함에 따라 리눅스가 엔터프라이즈 환경에서도 사용할 수 있게 되었고 OS 비용은 0이 되었다
  * 여러 도구를 통해 운영적 비용도 사라지게 되었다
  * 그 결과 도커가 탄생했다
* 변화는 유기적이며 갑자기 등장하지 않는다, 오픈 소스 운영체제와 C/D가 발전하면서 더욱 높은 확장성을 지닌 시스템 구축 기법을 발견해냈다
  * 마이크로 서비스는 이러한 방법론을 가르키기 위한 이름이다
* 아키텍처 특성은 프로젝트의 성공을 결정짓는 중요한 특성이며 최초 릴리스부터 유지 관리 단계까지 영향을 미친다


## 1.2 진화적 아키텍처
* 진화적 소프트웨어 아키텍처는 여러 차원에 걸쳐 **유도된 변화**와 **점진적 변화**를 지원한다

### 1.2.1 유도된 변화
* 아키텍처의 핵심 특성을 보호하는 방향으로 아키텍처가 변화하게 유도해야 한다
  * 예를 들어 성능이 중요하다면 성능을 유지하거나 증가하는 방향으로 유도해야 한다
  * 이를 위해 피트니스 함수라는 진화적 컴퓨팅 개념을 차용한다
    * 피트니스 함수는 시스템의 변화에 따라 정의한 '적합성'에 근거해 변화가 '적절한지' 판단한다
* 진화적 아키텍처의 목표도 이와 비슷하며 진화에 따른 변화가 핵심 특성에 어떤 영향을 미치는지 판단하기 위해 피트니스 함수를 정의하고
여러 도구를 통해 각 기능을 보호할 피트니스 함수가 정의되어야 한다
* 진화적 아키텍처는 무분별한 접근 방식이 아닌 빠른 변화와 아키텍처 특성의 엄밀함 사이에 균형을 가져오기 위한 개념이다
### 1.2.2 점진적 변화
* 점진적 변화는 소프트웨어 아키텍처의 두 측면, 점진적 빌드와 배포 방법을 나타낸다
> 어떤 시스템에 변경사항이 있을때 시스템의 일부를 변경하여 추가하고, 시스템의 다른 부분들은 점진적으로 변경된 부분을 적용해 나간다
>  * 이 과정에서 서비스 간 경로를 관찰하는 시스템을 통해 더 이상 라우팅이 없는 서비스를 식별하고 들어낼 것이다
>  * 시간이 지나 모든 시스템은 변경을 적용하고 기존 서비스는 들어내어 진다
### 1.2.3 다중 아키텍처 차원
* 시스템에는 여러 차원이 존재하며 각 차원들은 아키텍처의 일부이다
* 아키텍트는 진화의 관점에서 이를 반드시 고려해야 한다
  * 기술, 데이터, 보안, 운영/시스템
* 여러 관점으로 아키텍처의 차원이 형성되며 시간이 지남에 따라 여러 관심사는 트레이드 오프로 인해 얽히기 시작하며 아키텍처 특성을
보호하기 위해 피트니스 함수를 활용해야 한다
> 가용성 <> 분산
> 
> 확장성 <> 보안 
> 
> 위 예와 같이 트레이드 오프에 있는 관심사에서 어느 방향으로 진화해야 할지 결정하기 어렵기 때문에 피트니스 함수를 활용해 아키텍처 특성을 보호한다
* 아키텍트에게 생기는 두 가지 궁금증
  * 매 순간 모든 것이 변하는 세계에서 어떻게 장기적인 계획을 세울 수 있는가?
  * 아키텍처를 구축한 뒤 시간의 흐름에 따른 질적 저하를 어떻게 막을 수 있는가?

## 1.3 상시 변화하는 환경의 장기 계획 수립 가능성
* 우리가 사용하는 프로그래밍 플랫폼은 끊임없이 진화한다
  * 언어, 운영 환경, 퍼시스턴스 기술, 클라우드 서비스 등 분야를 가리지 않고 지속적으로 변화한다
  * 언제 어떻게 변할지 예측할 수 없으므로 변화를 가정하고 시스템을 설계해야 한다
* 과거 S/W 아키텍처의 변경은 어려우며 비용이 높다고 판단되었으나 기술의 발전은 전제를 무너뜨리고 손쉬운 변경을 기본 원칙으로 삼을 수 있게 만들었다

## 1.4 시간에 따른 아키텍처의 성능 저하 방지
* 비트 부패는 많은 조직에서 발생한다, 시간이 지남에 따라 최초 세웠던 아키텍처 특성은 저하되기 마련이다
  * 이러한 특성을 보호하기 위해서 진화성을 아키텍처의 특성으로 추가한다
  * 진화성은 시스템이 진화하며 나머지 특성을 보호한다는 의미이다
    * 이처럼 진화성은 다른 모든 아키텍처 특성을 보호하는 메타적 성격을 띤 아키텍처 래퍼가 된다

## 1.5 왜 진화인가?
* 여러 후보가 있지만 점진적, 유도된 아키텍처라는 두 가지 핵심 특성을 내포하기 때문이다
  * 후보 : 점진적, 지속적, 애자일, 반응형, 창발적
* 유도된 아키텍처는 달성해야할 최종 목표를 나타내는 정의가 된다
* 애자일은 아키텍처의 부재가 아닌 개발 과정에 존재하는 무가치한 관료적 행태를 배제하는 것이다
  * 무거운 의사결정
  * 문서화
* 완벽한 아키텍처란 없으며 설계자의 트레이드 오프 취급 방식이 다를 뿐이다
* 장기적 목표를 뒷받침할 구조와 거버넌스를 확보하고 이들이 거치적 거리지 않을 정도로 제한하는 것, 불필요한 형식과 저항을 낳지 않을 정도로 제한하는것
  * 이 두 조건 사이에 균형을 유지하는 것이 진화적 아키텍처의 핵심이다

---
