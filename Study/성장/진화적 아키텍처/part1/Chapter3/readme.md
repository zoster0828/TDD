# 점진적 변화 엔지니어링
* 진화적 아키텍처는 다양한 차원에 걸쳐 점진적 변화를 유도하는 아키텍처다
* 개발자의 관점과 운영자의 관점에서 논의해보자

## 3.1 점진적 변화
* PenultimateWidget은 새로운 별점 시스템을 추가하고 각 서비스는 원하는 시점에
점진적으로 신규 서비스로 전환한다. 모든 서비스가 전환되면 라우팅이 없어진 서비스를
생태계에서 자동으로 분리한다
---
* PenultimateWidget은 마이크로 서비스다
* 새로운 서비스는 기존 서비스보다 허용 값의 범위가 더 넓기 때문에(0.5단위) 고려할 필요가 없지만
* 신버전이 기존과 다른 계약을 해야 하는 경우 일반적으로 호출받는 서비스 내부에서 이루어지고 호출 당사자에겐 부담을 지우지 않는다

> 새로운 서비스가 기존 서비스를 호출하는 다른 서비스가 강제 업그레이드 할 필요는 없도록 하자
> 그런데 일반적으로는 조직 레벨에서 드라이브가 이루어지고 일정 기간안에 바꾸도록 하지 않으면
> 영원히 바뀌지 않을것 같다
> ---
> Study comment : 결국은 deadline을 두지 않으면 안된다. 그냥 두면 영원히 바뀌지 않음

* 신규 서비스가 배포되면 기존 서비스는 그대로 사용하고 새로 추가되는 서비스는 신규 서비스로 곧바로 연결된다
* 프록시를 통해 아키텍처 내부에서 자동화하고 더 이상 라우팅이 없는지 확인되면 제거된다
* Swabbie는 이러한 스타일의 진화적 아키텍처를 클라우드 기반으로 구현하는 도구다
  * https://github.com/spinnaker/swabbie
> 이러한 프록시 구현은 어떻게 할 수 있을까
> 
> endpoint가 proxy가 된다면 aws 내에서는 elb를 이용하는 방법이 있을텐데
> 
> 특정 헤더를 통해 분기 / from의 ip 또는 hostname등을 이용한 분기?
> 
> ---
> 
> Study comment : ~~api path의 특정 path 이용하여 분기~~
> 
> k8s면 namespace 정책을 이용해서 분기 할수도 있을듯


### 3.1.1 배포 파이프라인
* CD 는 지속적으로 통합한 내용을 배포한다
* 파이프라인 자동화를 시키는 것이 좋다
  * 도커 퍼펫 셰프 등의 도구를 활용하여 환경을 생성할 수 있다
* 이러한 배포 파이프라인은 피트니스 함수를 실행할 이상적인 장소가 된다
---
* 팬아웃하여
  * 현재 프로덕션에 부정적인 영향이 없고
  * 미래 상태 환경에 문제가 없는지 확인 한다
* 팬인 하여
  * 모든 작업이 통합된 하나의 배포 스레드를 만든다
---
* 사용자는 정기적인 신기능 보다 '빅뱅' 방식의 변화를 선호한다
* 기능 토글은 지속적 배포와 단계적 릴리즈를 동시에 수용하기 위해 자주 사용하는 방법이다
  * 배포는 되었지만 전환을 위해 환경 변수등을 이용하여 기능을 표시하거나 숨긴다
  * 신기능의 운영 시점과 소비자 릴리즈 시점을 분리할 수 있다
> 배포 되었으나 호출되지 않는 서비스에서 문제점을 먼저 발견할 수 있을까?
> 
> ---
> 
> Study comment : 배포 자체의 문제 같은것 보다도, 한번에 순간적으로 전환하기 위한 방법

### 3.1.2 PenultimateWidget의 피트니스 함수
* 청구서 처리 서비스를 업그레이드 하고자 한다
* 확장성 : 여러 리셀러에게 청구 정보 제공 가능해야함
* 서비스 통합 : 청구서의 변경으로 서비스 간 통합이 중단되면 안됨
* 보안 : 금전 문제이므로 높은 보안수준 요구
* 감사성 : 지역에 따라 과세에 대한 내용은 독립 법인의 감사를 받아야 함
---
* 이 요구사항을 만족하는 배포 파이프라인을 만들어보자
1. CI 복제 : 단위 및 기능 테스트 수행
2. 컨테이너화 및 배포 : integration test 수행 가능
3. 원자 피트니스 함수 실행 : 확장성 테스트 및 보안 침투 테스트
4. 전체 피트니스 함수 실행 : 계약 및 확장성 테스트
5. 보안 검토(수동)
6. 감사(수동)
7. 배포

### 3.1.3 자동화 빌드의 API 일관성 검증
* Penulti는 복잡한 회계 시스템 내부를 캡슐화했다. 회사 내외부에서 호출되므로 
변경 사항은 충돌하거나 장애가 발생하지 않도록 주의해야 한다
* 이러한 원칙을 지킬 수 있는 배포 파이프라인을 설계해보자
1. 설계 : 신규 API의 설계
2. 설정 : 배포 파이프라인에서 테스트와 검증을 수행하기 위해 필요한 운영 작업을 설정
3. 개발 : 개발한다
4. 배포 : 배포 진행, 신기능을 토글 방식으로 추가
5. 운영 : 피트니스 함수 및 상태 모니터링

> 당연한듯 보이는 이 원칙이 우리 팀에선 잘 지켜지는가?
> 
> 설계(open api spec)이 종종 개발 이후에 진행되는 경우가 있음, 
> 
> api가 변경될때마다 스펙을 바꾸기 귀찮다 보니 개발된 이후에 확정된 스펙을 문서화 하는 듯
> 
> 설정은 개발과 거의 같이 이루어지나 개발이 우선되는 경우도 있음
> 
> ---
> Study comment : 어차피 SPEC은 서로 이해할 수 있는 수단이면 되니까, 굳이 SPEC 문서를 따로 쓰지 않고
> 
> RESTDOC을 가지고 전달을 하는 편.
> 
> Intellij에서 자동으로 만들어주는 api 문서를 그냥 일단 주고 말하는 대로 만들어주는 느낌

* 피트니스 함수 검증 체인
1. API스펙을 검증한다
2. 스펙을 샌드박스 환경에서 테스트, 기존 Application이 신규 API 스펙에서도 작동하는지 검증
3. Pact를 사용해 통합 아키텍처 영역을 테스트
   * https://docs.pact.io
   * 소비자 주도 계약으로 통합 아키텍처의 원자 피트니스 함수 역할을 한다
   * 공급자는 소비자가 제공하는 테스트 캡슐을 항상 통과되도록 유지할 것을 약속한다
   * 이러한 기법을 '엔지니어링 안전망' 이라고 부른다

---
* 다른 엔지니어링과 달리 자동화된 검증을 통한 점진적인 변화가 가능하다
* 제조는 본질적으로 무료이며 가변적이다
* 이것은 자동화된 검증 절차를 등에 업은 시스템의 이점이며 자신감이다