# 4. 오류
> 모든 것이 잘못될 수 있고 잘못될 것이기 때문에 오류 사례를 신중하게 생각하지 않고는 견고하고
신뢰성 높은 코드를 작성할 수 없다.

## 4.1 복구 가능성
### 4.1.1 복구 가능한 오류
대부분의 오류는 치명적이지 않고, 복구할 수 있는 방법이 있다.

오류의 복구는 낮은 레벨에서 복구를 시도하는 것보다 높은 레벨로 보내고 처리해야 되는 경우가 많음.

### 4.1.2 복구할 수 없는 오류
오류의 복구가 불가능하다면 신속한 실패와 요란한 실패를 통해
문제를 발견하고 해결할 가능성을 최대화 하는 것이 합리적이다.

### 4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다
오류를 처리할 때는 아래 사항을 고려해야 한다.
* 사용하는 쪽에서 오류를 핸들링 하기를 원하는가?
* 오류를 처리할 필요가 있다는 것을 사용하는 쪽에서는 어떻게 알 수 있는가

사용하는 쪽에서 핸들링 해야하는 경우는 아래와 같다.
* 함수가 어디서 호출될지 모르고, 인자의 값이 정해져있지 않다.
* 코드가 미래에 재사용될 가능성이 희박하다. 재사용 된다면 첫번째의 가정이 의미가 없어질 수 있음을 의미한다.

### 4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라
호출하는 쪽에서 유효성 검사를 할 것이라고 예상하지 못할 수 있다.
또는 잘못된 형식이라고 인지를 못할 수도 있다.

따라서 이 함수에서 오류가 발생할 가능성이 있는것을 호출하는 쪽에서 인지하도록 한다.

### 4.2.1 신속하게 실패하라
가능한 문제의 발생 지점으로부터 가까운 곳에서 오류를 나타내어

복구할 수 있는 경우 다른 동작없이 즉각 복구에 들어갈 수 있고

복구할 수 없는 경우 개발자가 문제를 신속하게 파악하고 해결할 수 있는 기회를 제공한다.

오류에서 멀리 떨어져서 실패할수록 코드를 다시 역주행하며 오류의 위치를 찾기 위한 노력을 기울이게 된다.

### 4.2.2 요란하게 실패하라
개발 도중이나 테스트하는 동안 버그가 발견될 가능성이 크다. 

배포된 후 오류 보고를 보더라도 내용으로부터 버그의 위치를 즉시 알 수 있는 이점이 있다.

### 4.2.3 복구 가능성의 범위
예를 들어 서버 프로그램이라면 하나의 리퀘스트 오류로 서버가 멈추는 것은 바람직하지 않다.

오류 로그를 기록하고 발생률이 너무 높아지면 별도의 알람 메시지를 보낸다.

그러나 오류를 기록하기만 하고 상위 레벨로 보내지 않으면 오류가 감춰질 수 있다.

### 4.2.4 오류를 숨기지 않음
오류의 로깅과 같은 행위는 높은 계층의 코드에서 이루어져야 한다.
* 호출하는 쪽에서 오류로부터 복구할 수 있는 기회를 만든다.
* 오류가 드러난다. 개발팀에서 고칠 수 있도록

* 기본값 반환
  * 오류가 발생했다는 것을 감추게 될 수 있다.
  * 계좌 잔액 조회에서 오류시 0을 리턴한다면 실제 0인지 오류로 인한 0인지 알 수 없다.
* 빈 객체 반환
* 아무것도 하지 않는다.(return ;)

### 4.3 오류 전달 방법
* 명시적 방법
* 암시적 방법

### 4.3.1 요약: 예외
### 4.3.2 명시적 방법: checked exception
* io exception, sql, classnotfound
### 4.3.3 암시적 방법: 비검사 예외
* npe, arrayindexoutofbound
### 4.3.4 명시적 방법: 널값이 가능한 반환 유형
* null 안정성을 지원하는 언어에서는 null이 반환될 수 있는것을 인지하고 처리할 수 밖에 없으므로
명시적 방법이다.
### 4.3.5 명시적 방법: 리절트 반환 유형
* result 유형이 오류를 포함할 수 있다는 것이 인지된다면 result를 사용하는 것도 
명시적 방법이다.
### 4.3.6 명시적 방법: 아웃컴 반환 유형
* boolean을 이요해 성공 여부 반환
* 일부 언어에서는 확인해야 하도록 annotation을 붙일 수 있다.
### 4.3.7 암시적 방법: 프로미스 또는 퓨처
* 프로미스나 퓨처는 사용하는 쪽에서 핸들링하지 않을 수 있다.
### 4.3.8 암시적 방법: 매직값 반환
* 예를 들면 -1과 같은 값을 반환
* 오류를 알리기 좋은 방법은 아니다.

### 4.4 복구할 수 없는 오류의 전달
* 비검사 예외 발생
* 패닉 발생
* 체크나 어서션 사용
### 4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달
* 베스트 프랙티스가 없으므로 팀에서 동의한 철학을 우선시 하자.
### 4.5.1 비검사 예외 사용
* 코드의 구조가 개선된다. 오류를 처리하는 계층은 특정되어 있으므로 예외를 던지고 거기서만 처리한다.
* 너무 많은 예외를 던지면 무시하거나, null이 아니게 변환해버릴 수 있다.
  * 함수 변경 시 exception이 추가되면 너무 많은 클래스에 변경이 필요할 수 있다.
  * 이때 귀찮아서 오류를 감춰버릴 수 있다.
### 4.5.2 명시적 오류를 사용
* 매끄러운 오류 처리
  * 오류가 무엇인지 알고 있으면 매끄럽게 처리할 가능성이 커진다.
* 실수 방지
  * 여전히 무시할 수 있으나 적극적 노력이 필요한 위반이다.
  * 리뷰에서 잡힐 듯
* 예외 처리가 두더지 잡기 게임이 되지 않도록 방지
  * 지쳐서 Exception e로 퉁쳐 버릴 수 있음.
### 4.5.3 필자의 의견: 명시적 방식을 사용하라.
* 동의
### 4.6 컴파일러 경고를 무시하지 말라
* 여러 오류들이 표시되어 종종 무시하게 되는데, IDE에서 가능하면 실수할 수 있는 부분만 HINT를 켜두는게 도움이 되었음.
