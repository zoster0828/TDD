# 6. 예측 가능한 코드를 작성하라
### 6.1 매직값을 반환하지 말아야 한다
* -1 과 같은 매직값은 예측이 어렵다
### 6.1.1 매직값은 버그를 유발할 수 있다
* int age와 같은 함수에서 -1을 반환했을때 잘못된 값이라는 것을 사용하는 쪽에선 모를 수 있음
### 6.1.2 해결책: null, optional 또는 error를 반환하라
* 매직값 반환시 문제점은 함수의 세부조항까지 알고 있어야 한다는 점이다
* null을 반환하여 잘못된 경우 에러로 인지 할 수 있도록 한다
* optional을 반환하여 null이 올 수 있음을 알린다
  * 값이 없는 이유를 알 수 없을 수 있다. 이 경우 checked exception 통해 알리자

### 6.1.3 때때로 매직값이 우연히 발생할 수 있다
* 실수로 인해 초기화 값이 그대로 전달되는 의도하지 않은 매직값이 있을 수 있다
### 6.2 null 객체 패턴을 적절히 사용하라
* 빈 객체("" 또는 [])를 반환하여 NPE를 막는 방법도 있다
* 더 정교하게는 Object.empty() 를 사용하는 방법이 있다
* 다만 마찬가지로 예측할 수 없는 동작일 수 있다

> 특정 레이어에서는 null만 반환하고 특정 레이어는 null이 절대 반환되지 않도록 하는 방법 사용중
>  * infra, adapter 에서는 logic과 관련없이 값이 없으면 null 반환
>  * application에서는 null을 반드시 체크하고 동작
>  * domain은 null 객체 가정하지 않음
### 6.2.1 빈 컬렉션을 반환하면 코드가 개선될 수 있다
* 빈 컬렉션인 경우 null일 확인 필요없이 iteration을 돌리는 방법이 유용하긴 함
### 6.2.2 빈 문자열을 반환하는 것도 때로는 문제가 될 수 있다
* ID와 같은 경우 문자열이 비어서 RETURN 되면 에러인지 확인하기 어렵다

### 6.2.3 더 복잡한 null 객체는 예측을 벗어날 수 있다
### 6.2.4 null 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다
* Object.empty()와 같은 방법을 사용할 경우 객체를 받았음에도 내부가 null인 문제도 있음
```java
public class Task {
    
  private String taskId;
  private TaskType taskType;
  
  public static Task empty() {
      return new Task();
    }
    
  public boolean isEmpty() {
      return taskId == null;
    }
}
```
* 위 경우 task객체가 있는지 알고 사용하려다 taskType에서 NPE를 받을 수 있음
* isEmpty를 사용하여 확인할 수 있으나 null 체크 하는것과 비슷하게 생각됨

### 6.3 예상치 못한 부수 효과를 피하라
* 함수의 호출이 외부의 상태에 변화를 가하는 것
### 6.3.1 분명하고 의도적인 부수 효과는 괜찮다
* 이름을 통해 명확하게 하자
### 6.3.2 예기치 않은 부수 효과는 문제가 될 수 있다
* 함수가 read / get 인 경우 일반적으로 부수 효과가 없을 것으로 가정한다
* 의도치 않은 사용으로 인해 퍼포먼스 이슈 또는 버그가 발생할 수 있다
* getUserInfo()에서 user의 상태를 변경하면서 꺼낸다면?

### 6.3.3 해결책: 부수 효과를 피하거나 그 사실을 분명하게 하라
* 함수의 이름을 통해 부수효과까지 표현하자

### 6.4 입력 매개변수를 수정하는 것에 주의하라
### 6.4.1 입력 매개변수를 수정하면 버그를 초래할 수 있다
### 6.4.2 해결책: 변경하기 전에 복사하라
* 변경이 필요하다면 새 자료구조에 값을 복사하고 변경하자

> 변경이 가해졌다면 해당 변경사항을 return 하는 방법은 어떤지?

### 6.5 오해를 일으키는 함수는 작성하지 말라
### 6.5.1 중요한 입력이 누락되었을 때 아무것도 하지 않으면 놀랄 수 있다
* 예제에 있는 함수와 같이 입력을 출력하는 함수에서 입력이 null인 경우 아무것도 하지 않는다면 오해가 발생한다
> 아무것도 없는 출력을 제공하는 것 vs 에러를 발생 시키는 것
### 6.5.2 해결책: 중요한 입력은 필수 항목으로 만들라
* @nonNull
### 6.6 미래를 대비한 enum 처리
> 일반적으로 state machine 처리시 많이 사용하고 있음
> 사용 가능한 국가의 region
### 6.6.1 미래에 추가될 수 있는 enum을 암묵적으로 처리하는 것은 문제가 될 수 있다
* 현재 있는 값을 문제로 그 외는 ok라고 했을때 문제값이 enum에 추가되면 판별 함수를 수정 안할 우려가 있음
### 6.6.2 해결책: 모든 경우를 처리하는 스위치 문을 사용하라
* 모든 값을 처리하고 그 외는 exception 발생
### 6.6.3 기본 케이스를 주의하라
* default는 6.6.1과 같은 문제를 만들 수 있다
### 6.6.4 주의 사항: 다른 프로젝트의 열거형에 의존
* 우리가 핸들링 할 수 없는 enum값에 의존하지 말자
### 6.7 이 모든 것을 테스트로 해결할 수는 없는가?
* 좋은 테스트가 나쁜 코드를 막아줄 것이라는 기대는 종종 벗어난다