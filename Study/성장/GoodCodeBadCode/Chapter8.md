# 8. 코드를 모듈화하라
## 8.1 의존성 주입의 사용을 고려하라
일반적으로 잘 작성된 코드는 중복되지 않은 전용 코드를 사용하여 하위 문제를 해결하지만
의존성 주입을 통해 재구성할 수 있는 방식으로 유용할 수 있다.
### 8.1.1 하드 코드화된 의존성은 문제가 될 수 있다

* RoutePlanner 클래스는 생성시에 RoadMap에 미국만 생성하도록 하드코딩 되어있고
다른 지역의 여행에는 사용할 수 없다.

* NorthAmericaRoadMap의 계약이 변경된 경우를 반영할 수 없음

### 8.1.2 해결책: 의존성 주입을 사용하라
* RoutePlanner의 생성자에서 RoadMap을 주입받고 생성하면 됨
* 좀 더 심플하게 RoadMap의 팩토리를 만들어 줄 수도 있음

### 8.1.3 의존성 주입을 염두에 두고 코드를 설계하라

## 8.2 인터페이스에 의존하라
클래스가 인터페이스를 구현하고 있다면 클래스에 직접 의존하기보다 인터페이스 의존하는것이 일반적으로 더 바람직하다

### 8.2.1 구체적인 구현에 의존하면 적응성이 제한된다
* 종종 Spring에서 interface가 아닌 구현체를 @Autowired 하는 경우 있음
### 8.2.2 해결책: 가능한 경우 인터페이스에 의존하라
* dependency inversion

## 8.3 클래스 상속을 주의하라
### 8.3.1 클래스 상속은 문제가 될 수 있다
* 일부 기능만 사용하고 싶어도 모두 가져가야 함
* 상속은 추상화 계층에 방해가 될 수 있음
  * 의도치 않은 기능이더라도 노출되었다면 사용될 가능성이 있고, 시간이 지나면 이미 많은 곳에서 사용하고 있어 수정이 어려워질 수 있음
* 상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다

### 8.3.2 해결책: 구성을 사용하라
* 의존성 주입을 통해 필요한 클래스만 받아서 사용하자


- lombok delegate
  - 잘 안 쓰고 직접 구현했었는데 잘 써보면 좋을것 같기도 함

### 8.3.3 진정한 is-a 관계는 어떤가?
* 취약한 베이스 클래스
  * 베이스가 수정되었을때 상속한 클래스가 잘 동작한다는 보장이 없음
* 다중상속
  * 두개의 베이스가 같은 함수를 다르게 제공할때 어떤것을 사용할지 알 수 없음
* 문제가 있는 계층 구조
  * 다중상속이 지원되지 않으면 상속의 상속을 해야 하는데 이 경우 스콥이 더 좁아지고 사용하기 어렵다

- 상속은 일반적으로 잘 써야 한다고 말하지만 잘 쓰는것이 어렵다.
  - 도메인을 모델링 할 때 어떤 도메인을 확장하는 도메인을 상속으로 구현한다면,
    결코 변하지 않음을 가정해야 하고 결코 변하지 않음을 가정하는 것은 수정이 어렵다는 의미이다.

## 8.4 클래스는 자신의 기능에만 집중해야 한다
### 8.4.1 다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다
* 상위 클래스의 구현을 하위 클래스가 가지고 있다면 상위 클래스의 변경이 하위 클래스에
전파되지 않을 수 있다
### 8.4.2 해결책: 자신의 기능에만 충실한 클래스를 만들라

## 8.5 관련 있는 데이터는 함께 캡슐화하라
* 하나의 클래스에 많은 것이 있으면 문제가 될 수 있지만 함께 있는 것이 합리적일때는 그것의 이점을 놓치지 말자
### 8.5.1 캡슐화되지 않은 데이터는 취급하기 어려울 수 있다
* 캡슐화를 제대로 하지 않으면 관심없는 세부사항에 신경써야 함
* 모듈화의 목적 중 하나는 요구 사항의 변경이 있을 때 해당 요구 사항과 직접 관련 있는 코드만 수정하고자 하는것
### 8.5.2 해결책: 관련된 데이터는 객체 또는 클래스로 그룹화하라
* 그룹화 할 수 있는 데이터를 모아서 제공하면 관심사에 대해서만 신경 쓸 수 있다.
* 그러나 너무 많은 개념을 모을 경우에는 또 문제가 될 수 있다.
* 밀접한 연관이 있고, 전체가 필요한 경우에는 캡슐화 하자
## 8.6 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라
* 구현의 세부 정보가 반환에 노출되면 수정이 어려워진다
### 8.6.1 반환 형식에 구현 세부 사항이 유출될 경우 문제가 될 수 있다
* 서버에서 데이터를 가져온다고 해서 return에 http관련 내용이 포함되면 사용하는 쪽에서 http 관련 내용을 구현해야 함

> 이런 형태가 아니더라도 하나의 계층을 지날때는 새로운 dto를 만들어 주는데 어떻게 하는지?

### 8.6.2 해결책: 추상화 계층에 적합한 유형을 반환하라
> infra의 dto가 application 또는 domain 까지 올라가는 경우?

## 8.7 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라
### 8.7.1 예외 처리 시 구현 세부 사항이 유출되면 문제가 될 수 있다
* 특정 구현에 종속된 예외 처리는 곤란하다
> Exception 어떤 식으로 그룹화 하는지
### 8.7.2 해결책: 추상화 계층에 적절한 예외를 만들라
> 각각에 일일이 만들어주면 좋은데, 너무 많은 종류의 예외는 오히려 어렵지 않을까?
