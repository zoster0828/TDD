# 4. 오류
> 모든 것이 잘못될 수 있고 잘못될 것이기 때문에 오류 사례를 신중하게 생각하지 않고는 견고하고
신뢰성 높은 코드를 작성할 수 없다.

## 4.1 복구 가능성
### 4.1.1 복구 가능한 오류
대부분의 오류는 치명적이지 않고, 복구할 수 있는 방법이 있다.

오류의 복구는 낮은 레벨에서 복구를 시도하는 것보다 높은 레벨로 보내고 처리해야 되는 경우가 많음.

### 4.1.2 복구할 수 없는 오류
오류의 복구가 불가능하다면 신속한 실패와 요란한 실패를 통해
문제를 발견하고 해결할 가능성을 최대화 하는 것이 합리적이다.

### 4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다
오류를 처리할 때는 아래 사항을 고려해야 한다.
* 사용하는 쪽에서 오류를 핸들링 하기를 원하는가?
* 오류를 처리할 필요가 있다는 것을 사용하는 쪽에서는 어떻게 알 수 있는가

사용하는 쪽에서 핸들링 해야하는 경우는 아래와 같다.
* 함수가 어디서 호출될지 모르고, 인자의 값이 정해져있지 않다.
* 코드가 미래에 재사용될 가능성이 희박하다. 재사용 된다면 첫번째의 가정이 의미가 없어질 수 있음을 의미한다.

### 4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라
호출하는 쪽에서 유효성 검사를 할 것이라고 예상하지 못할 수 있다.
또는 잘못된 형식이라고 인지를 못할 수도 있다.

따라서 이 함수에서 오류가 발생할 가능성이 있는것을 호출하는 쪽에서 인지하도록 한다.

### 4.2.1 신속하게 실패하라
가능한 문제의 발생 지점으로부터 가까운 곳에서 오류를 나타내어

복구할 수 있는 경우 다른 동작없이 즉각 복구에 들어갈 수 있고

복구할 수 없는 경우 개발자가 문제를 신속하게 파악하고 해결할 수 있는 기회를 제공한다.

오류에서 멀리 떨어져서 실패할수록 코드를 다시 역주행하며 오류의 위치를 찾기 위한 노력을 기울이게 된다.

### 4.2.2 요란하게 실패하라
개발 도중이나 테스트하는 동안 버그가 발견될 가능성이 크다. 

배포된 후 오류 보고를 보더라도 내용으로부터 버그의 위치를 즉시 알 수 있는 이점이 있다.

### 4.2.3 복구 가능성의 범위
예를 들어 서버 프로그램이라면 하나의 리퀘스트 오류로 서버가 멈추는 것은 바람직하지 않다.

오류 로그를 기록하고 발생률이 너무 높아지면 별도의 알람 메시지를 보낸다.

그러나 오류를 기록하기만 하고 상위 레벨로 보내지 않으면 오류가 감춰질 수 있다.

### 4.2.4 오류를 숨기지 않음
오류의 로깅과 같은 행위는 높은 계층의 코드에서 이루어져야 한다.
* 호출하는 쪽에서 오류로부터 복구할 수 있는 기회를 만든다.
* 오류가 드러난다. 개발팀에서 고칠 수 있도록

* 기본값 반환
  * 오류가 발생했다는 것을 감추게 될 수 있다.
  * 계좌 잔액 조회에서 오류시 0을 리턴한다면 실제 0인지 오류로 인한 0인지 알 수 없다.
* 빈 객체 반환
* 아무것도 하지 않는다.(return ;)

### 4.3 오류 전달 방법
* 명시적 방법 : checked exception
* 암시적 방법 : runtime exception

### 4.3.1 요약: 예외
### 4.3.2 명시적 방법: 검사 예외
### 4.3.3 암시적 방법: 비검사 예외
### 4.3.4 명시적 방법: 널값이 가능한 반환 유형
### 4.3.5 명시적 방법: 리절트 반환 유형
### 4.3.6 명시적 방법: 아웃컴 반환 유형

