# 6장 키-값 저장소 설계
* Key - value store
* dynamo, memcached, redis

## 문제 이해 및 설계 범위 확정
* 키-값 쌍의 크기는 10KB 이하
* 큰 데이터도 저장 가능
* 고가용성
* 쉬운 확장
* CONSISTENCY 조정 가능
* 짧은 latency

## 단일 서버 키-값 저장소
* 메모리에 올리는 것
  * hashmap
* 메모리 부족을 개선하기 위한 방법
  * 압축
  * 일부만 memory에 나머지는 디스크에

## 분산 키-값 저장소
* 분산 해시 테이블
### CAP 정리
* consistency,, availability, partition tolerance를 만족하는 시스템을 설계하는 것은 불가능하다
* 데이터 일관성 : 어느 노드에 접근하든지 같은 데이터
* 가용성 : 일부에 장애가 있어도 전체는 동작한다
* 파티션 감내 : 네트워크에 파티션이 생기더라도 시스템은 동작한다
* 두가지를 충족하면 한가지는 반드시 희생됨

* 이상적으로는 네트워크는 파티션 되지 않고 데이터는 잘 복제되어 일관성과 가용성 모두 만족
* 일부 파티션에 문제가 생기면
  * 일관성과 가용성 중 하나를 선택한다
  * N3가 죽었다면 N3에 있는 데이터가 N1,N2로 복제되지 않았을 경우 오래된 사본을 갖고 있게 된다
  * 가용성을 희생한다면
    * N1/N2에 대해 쓰기 연산을 중단한다
  * 일관성을 희생한다면
    * 읽기 연산을 허용하고 N1/N2 에 쓰기도 허용한다, 데이터는 일관성이 깨졌지만 시스템에는 문제가 없다

## 시스템 컴포넌트
### 데이터 파티션
* 전체 데이터를 한대 서버에 넣는것은 불가능, 데이터를 여러개의 파티션으로 분할 저장한다
  * 데이터를 고르게 분산할 수 있는가
  * 노드가 추가 삭제될 때 데이터의 이동을 최소화할 수 있는지
  * 예제에는 없지만 KAFKA의 파티션 전략도 해시링으로 보임
    * 초기에는 해시 테이블이었으나, 해시링으로 변경한듯
### 데이터 다중화
* 가용성을 위해 REPLICATION이 필요(일반적으로 3, S3는 6이라고 함)
* 가상 노드로 인해 중복된 물리서버에 저장되지 않도록 해야 함

### 데이터 일관성
* REPLICATION된 